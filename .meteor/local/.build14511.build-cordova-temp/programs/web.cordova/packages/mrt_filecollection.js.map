)]}'
{"version":3,"file":"/packages/mrt:filecollection.js","sources":["mrt:filecollection/gridFS.coffee","mrt:filecollection/resumable/resumable.js","mrt:filecollection/resumable_client.coffee","mrt:filecollection/gridFS_client.coffee"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA,KAAK,CAAC,gBAAN,GAAyB,IAAE,IAAF,GAAO,IAAhC;;KACK,CAAC,WAAN,GAAoB,IADpB;;KAGK,CAAC,WAAN,GAAoB,SAAC,IAAD,EAAY,SAAZ;AACjB;;IADkB,OAAO;GACzB;;AACG,SAAS,UAAM,CAAC,UAAU,CAAC,QAAlB,CAA2B,KAAE,IAAI,CAAC,GAAlC,CAAT,CADH;;AAGG,SAAS,UAAM,CAAC,UAAU,CAAC,QAAlB,EAAT,CAHH;;EAIA,UAAU,EAJV;EAKA,OAAO,CAAC,GAAR,GAAc,EALd;EAMA,OAAO,CAAC,MAAR,GAAiB,CANjB;EAOA,OAAO,CAAC,GAAR,GAAc,kCAPd;EAQA,OAAO,CAAC,UAAR,GAAyB,UARzB;EASA,OAAO,CAAC,SAAR,GAAoB,SATpB;EAUA,OAAO,CAAC,QAAR,2CAAmC,EAVnC;EAWA,OAAO,CAAC,QAAR,6CAAmC,EAXnC;EAYA,OAAO,CAAC,OAAR,4CAAiC,EAZjC;EAaA,OAAO,CAAC,WAAR,gDAAyC,0BAbzC;AAcA,SAAO,OAAP,CAfiB;CAHpB;A;;;;;;;;;;;;;;;;;ACNA,E;AACA,c;AACA,uC;AACA,mC;AACA,sD;AACA,E;;AAEA,Y;AACA,a;;AAEA,iC;AACA,yC;AACA,iC;AACA,K;AACA,uB;AACA,4B;AACA,0D;AACA,yB;AACA,yB;AACA,6B;AACA,sB;AACA,oB;AACA,+C;AACA,qB;AACA,+C;AACA,qB;AACA,mD;AACA,qB;AACA,2G;AACA,qB;AACA,oC;;;AAGA,iB;AACA,iB;AACA,iB;AACA,kB;AACA,4B;AACA,2B;AACA,4B;AACA,+B;AACA,oC;AACA,e;AACA,iB;AACA,sB;AACA,yB;AACA,wC;AACA,iB;AACA,sB;AACA,oC;AACA,gC;AACA,mC;AACA,2C;AACA,yB;AACA,4B;AACA,mB;AACA,0D;AACA,4C;AACA,mG;AACA,Q;AACA,oB;AACA,2D;AACA,0I;AACA,Q;AACA,4B;AACA,2D;AACA,wI;AACA,Q;AACA,mB;AACA,yD;AACA,4H;AACA,O;AACA,M;AACA,sB;AACA,4B;AACA,sB;AACA,+C;AACA,8B;AACA,yB;AACA,oC;AACA,gD;AACA,W;AACA,uB;AACA,O;AACA,+C;AACA,2C;AACA,yE;AACA,qC;AACA,O;AACA,0C;AACA,yE;AACA,0C;AACA,O;AACA,sC;AACA,yE;AACA,yC;AACA,O;AACA,M;AACA,I;AACA,a;AACA,2B;AACA,gH;AACA,4D;AACA,kB;AACA,oC;AACA,mD;AACA,M;AACA,wB;AACA,wD;AACA,oB;AACA,qE;AACA,kE;AACA,wC;AACA,+C;AACA,oE;AACA,mE;AACA,O;AACA,+D;AACA,mD;AACA,M;AACA,I;AACA,I;AACA,4E;AACA,c;AACA,6B;AACA,4B;AACA,2B;AACA,Q;AACA,iC;AACA,4C;AACA,0C;AACA,gC;AACA,8C;AACA,W;AACA,gB;AACA,wB;AACA,qB;AACA,gD;AACA,W;AACA,S;AACA,Q;AACA,8C;AACA,0D;AACA,0C;AACA,8B;AACA,S;AACA,gI;AACA,6B;AACA,2E;AACA,Q;AACA,qC;AACA,2B;;AAEA,wC;AACA,8B;AACA,0B;AACA,yB;AACA,W;AACA,sB;AACA,W;;AAEA,sB;AACA,Q;AACA,gC;AACA,uB;AACA,iC;AACA,mC;AACA,kD;AACA,wC;AACA,yD;AACA,gB;AACA,gE;AACA,S;AACA,Q;AACA,iC;AACA,wC;AACA,qC;AACA,wB;AACA,gB;AACA,wB;AACA,S;AACA,yC;AACA,O;AACA,M;;AAEA,iC;AACA,0B;AACA,+D;AACA,M;AACA,kC;AACA,yB;AACA,M;;AAEA,uE;AACA,4D;AACA,2C;AACA,yB;AACA,yL;AACA,4F;AACA,6H;AACA,0E;AACA,mC;AACA,gB;AACA,0D;AACA,uB;AACA,S;AACA,O;AACA,qB;AACA,uC;AACA,4C;AACA,iE;AACA,Q;AACA,0E;AACA,sD;AACA,uB;AACA,S;;AAEA,6E;AACA,yD;AACA,uB;AACA,S;AACA,6E;AACA,yD;AACA,uB;AACA,S;;AAEA,qC;AACA,wF;AACA,6C;AACA,uC;AACA,4B;AACA,0B;AACA,kF;AACA,yC;AACA,e;AACA,c;AACA,S;AACA,mC;AACA,mC;AACA,W;AACA,M;;AAEA,4B;AACA,+C;AACA,mB;AACA,kB;AACA,qC;AACA,0B;AACA,oC;AACA,oB;AACA,+F;AACA,yB;AACA,6D;AACA,6D;AACA,uB;AACA,uB;AACA,yB;;AAEA,yD;AACA,gD;AACA,iE;AACA,sB;AACA,wB;AACA,iD;AACA,gB;AACA,qB;AACA,oB;AACA,wB;AACA,wB;AACA,uD;AACA,gB;AACA,uB;AACA,4B;AACA,2E;AACA,8B;AACA,2D;AACA,W;AACA,gB;AACA,qB;AACA,8C;AACA,gB;AACA,S;AACA,Q;;AAEA,uD;AACA,yD;AACA,oB;AACA,2B;AACA,+B;AACA,2B;AACA,sC;AACA,uC;AACA,sB;AACA,yB;AACA,W;AACA,W;AACA,gE;AACA,Q;AACA,4B;AACA,qC;AACA,+B;AACA,sB;AACA,+B;AACA,qC;AACA,wC;AACA,sB;AACA,6C;AACA,W;AACA,W;AACA,qC;AACA,+C;AACA,Q;AACA,2B;AACA,sB;AACA,+B;AACA,yD;AACA,kD;AACA,4B;AACA,W;AACA,Q;AACA,+B;AACA,kB;AACA,uB;AACA,4C;AACA,sB;AACA,4B;AACA,wE;AACA,6E;AACA,0E;AACA,yC;AACA,yF;AACA,2E;AACA,iB;AACA,mB;AACA,qC;AACA,sD;AACA,a;AACA,Q;AACA,8B;AACA,6B;AACA,4C;AACA,oB;AACA,0B;AACA,sC;AACA,+C;AACA,gF;AACA,W;AACA,kD;AACA,2G;AACA,8B;AACA,oB;AACA,Q;AACA,iC;AACA,8B;AACA,0C;AACA,2C;AACA,6B;AACA,0B;AACA,W;AACA,W;AACA,0B;AACA,Y;AACA,gC;AACA,gC;AACA,0C;AACA,sC;AACA,uF;AACA,+B;AACA,0B;AACA,W;AACA,W;AACA,6B;AACA,Q;AACA,gC;AACA,0C;AACA,mD;AACA,gB;AACA,+B;AACA,W;AACA,Q;AACA,+B;AACA,wB;AACA,Q;;;AAGA,6B;AACA,8C;AACA,oB;AACA,mB;AACA,K;;AAEA,qE;AACA,mB;AACA,kB;AACA,qC;AACA,oC;AACA,0B;AACA,mC;AACA,wC;AACA,wB;AACA,4B;AACA,0C;AACA,uB;AACA,oB;AACA,6B;AACA,6E;;AAEA,4B;AACA,4C;AACA,mB;AACA,uC;AACA,kE;AACA,+E;AACA,uF;AACA,kC;AACA,O;AACA,mB;;AAEA,wH;AACA,0B;AACA,8C;AACA,qC;;AAEA,sC;AACA,0B;AACA,kC;AACA,iC;AACA,4C;AACA,6C;AACA,kB;AACA,qB;AACA,W;AACA,U;AACA,2D;AACA,4D;;AAEA,0C;AACA,wB;AACA,6C;AACA,qF;AACA,2C;AACA,gF;AACA,W;AACA,2C;AACA,wF;AACA,iG;AACA,0G;AACA,yF;AACA,oF;AACA,uG;AACA,6F;AACA,qG;AACA,qG;AACA,gD;AACA,gD;AACA,+C;AACA,4D;AACA,uC;AACA,oD;AACA,uC;AACA,W;AACA,yB;AACA,Q;;AAEA,wC;AACA,8B;AACA,iB;AACA,Q;;AAEA,sD;AACA,0B;AACA,gD;AACA,8C;AACA,qC;AACA,+D;AACA,yB;AACA,wB;AACA,W;AACA,S;AACA,iD;AACA,mB;AACA,iB;AACA,S;;AAEA,8C;AACA,qC;;AAEA,mB;AACA,8D;AACA,oG;AACA,mC;AACA,gD;AACA,W;AACA,+B;AACA,kB;AACA,qB;AACA,+B;AACA,+B;;AAEA,8C;AACA,sC;AACA,kC;AACA,kD;AACA,4C;AACA,6C;AACA,kB;AACA,6C;AACA,sB;AACA,wB;AACA,yE;AACA,6C;AACA,oC;AACA,gD;AACA,oB;AACA,uB;AACA,a;AACA,W;AACA,U;AACA,2D;AACA,4D;;AAEA,qD;AACA,qB;AACA,2C;AACA,oD;AACA,6D;AACA,4C;AACA,uC;AACA,0D;AACA,gD;AACA,wD;AACA,uD;AACA,U;AACA,6B;AACA,4C;AACA,qF;AACA,2C;AACA,uB;AACA,W;;AAEA,wJ;AACA,8D;AACA,sB;AACA,oC;AACA,Q;AACA,6C;AACA,4C;AACA,uB;AACA,0B;AACA,uC;AACA,kF;AACA,a;AACA,wC;AACA,gB;AACA,4C;AACA,gC;AACA,uC;AACA,6B;AACA,a;AACA,4D;AACA,S;AACA,Q;AACA,mC;AACA,+C;AACA,4D;AACA,uC;AACA,oD;AACA,uC;AACA,W;AACA,yB;AACA,Q;AACA,2B;AACA,0B;AACA,gC;AACA,qB;AACA,Q;AACA,4B;AACA,8D;AACA,4B;AACA,qF;AACA,uE;AACA,8B;AACA,2B;AACA,4B;AACA,uC;AACA,yG;AACA,8B;AACA,gB;AACA,iC;AACA,gC;AACA,8B;AACA,yH;AACA,gD;AACA,4B;AACA,kB;AACA,0E;AACA,sE;AACA,sB;AACA,8B;AACA,W;AACA,S;AACA,Q;AACA,6B;AACA,gD;AACA,Q;AACA,sC;AACA,4D;AACA,4E;AACA,qC;AACA,2B;AACA,kB;AACA,uB;AACA,qB;AACA,2B;AACA,uB;AACA,2B;AACA,gB;AACA,0D;AACA,S;AACA,Q;AACA,mB;AACA,K;;AAEA,Y;AACA,mC;AACA,wB;;AAEA,6E;AACA,iF;AACA,sE;AACA,oD;AACA,wC;AACA,gH;AACA,kC;AACA,yB;AACA,0B;AACA,W;AACA,wJ;AACA,qD;AACA,yB;AACA,0B;AACA,W;AACA,W;AACA,+B;AACA,O;;AAEA,4D;AACA,sC;AACA,oC;AACA,8C;AACA,yE;AACA,0B;AACA,0B;AACA,2B;AACA,Y;AACA,a;AACA,S;AACA,gC;AACA,S;AACA,6B;;AAEA,kF;AACA,8B;AACA,sC;AACA,gC;AACA,6B;AACA,wB;AACA,S;AACA,S;AACA,wB;AACA,kD;AACA,2B;AACA,O;AACA,oB;AACA,M;;;AAGA,sC;AACA,qD;AACA,qE;;AAEA,2C;AACA,kB;AACA,+D;AACA,0B;AACA,gB;AACA,kD;AACA,6C;AACA,uC;AACA,uD;AACA,oC;AACA,wC;AACA,0B;AACA,0B;AACA,uC;AACA,oB;AACA,qC;AACA,S;AACA,4C;AACA,yD;AACA,qD;AACA,gB;AACA,4C;AACA,S;AACA,wB;AACA,mE;AACA,gB;AACA,mD;AACA,S;AACA,2E;AACA,qD;AACA,oD;AACA,8B;AACA,kB;AACA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","sourcesContent":["############################################################################\n#     Copyright (C) 2014 by Vaughn Iverson\n#     fileCollection is free software released under the MIT/X11 license.\n#     See included LICENSE file for details.\n############################################################################\n\nshare.defaultChunkSize = 2*1024*1024\nshare.defaultRoot = 'fs'\n\nshare.insert_func = (file = {}, chunkSize) ->\n   try\n      id = new Meteor.Collection.ObjectID(\"#{file._id}\")\n   catch\n      id = new Meteor.Collection.ObjectID()\n   subFile = {}\n   subFile._id = id\n   subFile.length = 0\n   subFile.md5 = 'd41d8cd98f00b204e9800998ecf8427e'\n   subFile.uploadDate = new Date()\n   subFile.chunkSize = chunkSize\n   subFile.filename = file.filename ? ''\n   subFile.metadata = file.metadata ? {}\n   subFile.aliases = file.aliases ? []\n   subFile.contentType = file.contentType ? 'application/octet-stream'\n   return subFile\n","/*\n* MIT Licensed\n* http://www.23developer.com/opensource\n* http://github.com/23/resumable.js\n* Steffen Tiedemann Christensen, steffen@23company.com\n*/\n\n(function(){\n\"use strict\";\n\n  var Resumable = function(opts){\n    if ( !(this instanceof Resumable) ) {\n      return new Resumable(opts);\n    }\n    this.version = 1.0;\n    // SUPPORTED BY BROWSER?\n    // Check if these features are support by the browser:\n    // - File object type\n    // - Blob object type\n    // - FileList object type\n    // - slicing files\n    this.support = (\n                   (typeof(File)!=='undefined')\n                   &&\n                   (typeof(Blob)!=='undefined')\n                   &&\n                   (typeof(FileList)!=='undefined')\n                   &&\n                   (!!Blob.prototype.webkitSlice||!!Blob.prototype.mozSlice||!!Blob.prototype.slice||false)\n                   );\n    if(!this.support) return(false);\n\n\n    // PROPERTIES\n    var $ = this;\n    $.files = [];\n    $.defaults = {\n      chunkSize:1*1024*1024,\n      forceChunkSize:false,\n      simultaneousUploads:3,\n      fileParameterName:'file',\n      throttleProgressCallbacks:0.5,\n      query:{},\n      headers:{},\n      preprocess:null,\n      method:'multipart',\n      prioritizeFirstAndLastChunk:false,\n      target:'/',\n      testChunks:true,\n      generateUniqueIdentifier:null,\n      maxChunkRetries:undefined,\n      chunkRetryInterval:undefined,\n      permanentErrors:[404, 415, 500, 501],\n      maxFiles:undefined,\n      withCredentials:false,\n      xhrTimeout:0,\n      maxFilesErrorCallback:function (files, errorCount) {\n        var maxFiles = $.getOpt('maxFiles');\n        alert('Please upload ' + maxFiles + ' file' + (maxFiles === 1 ? '' : 's') + ' at a time.');\n      },\n      minFileSize:1,\n      minFileSizeErrorCallback:function(file, errorCount) {\n        alert(file.fileName||file.name +' is too small, please upload files larger than ' + $h.formatSize($.getOpt('minFileSize')) + '.');\n      },\n      maxFileSize:undefined,\n      maxFileSizeErrorCallback:function(file, errorCount) {\n        alert(file.fileName||file.name +' is too large, please upload files less than ' + $h.formatSize($.getOpt('maxFileSize')) + '.');\n      },\n      fileType: [],\n      fileTypeErrorCallback: function(file, errorCount) {\n        alert(file.fileName||file.name +' has type not allowed, please upload files of type ' + $.getOpt('fileType') + '.');\n      }\n    };\n    $.opts = opts||{};\n    $.getOpt = function(o) {\n      var $opt = this;\n      // Get multiple option if passed an array\n      if(o instanceof Array) {\n        var options = {};\n        $h.each(o, function(option){\n          options[option] = $opt.getOpt(option);\n        });\n        return options;\n      }\n      // Otherwise, just return a simple option\n      if ($opt instanceof ResumableChunk) {\n        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }\n        else { $opt = $opt.fileObj; }\n      }\n      if ($opt instanceof ResumableFile) {\n        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }\n        else { $opt = $opt.resumableObj; }\n      }\n      if ($opt instanceof Resumable) {\n        if (typeof $opt.opts[o] !== 'undefined') { return $opt.opts[o]; }\n        else { return $opt.defaults[o]; }\n      }\n    };\n    \n    // EVENTS\n    // catchAll(event, ...)\n    // fileSuccess(file), fileProgress(file), fileAdded(file, event), fileRetry(file), fileError(file, message),\n    // complete(), progress(), error(message, file), pause()\n    $.events = [];\n    $.on = function(event,callback){\n      $.events.push(event.toLowerCase(), callback);\n    };\n    $.fire = function(){\n      // `arguments` is an object, not array, in FF, so:\n      var args = [];\n      for (var i=0; i<arguments.length; i++) args.push(arguments[i]);\n      // Find event listeners, and support pseudo-event `catchAll`\n      var event = args[0].toLowerCase();\n      for (var i=0; i<=$.events.length; i+=2) {\n        if($.events[i]==event) $.events[i+1].apply($,args.slice(1));\n        if($.events[i]=='catchall') $.events[i+1].apply(null,args);\n      }\n      if(event=='fileerror') $.fire('error', args[2], args[1]);\n      if(event=='fileprogress') $.fire('progress');\n    };\n    \n    \n    // INTERNAL HELPER METHODS (handy, but ultimately not part of uploading)\n    var $h = {\n      stopEvent: function(e){\n        e.stopPropagation();\n        e.preventDefault();\n      },\n      each: function(o,callback){\n        if(typeof(o.length)!=='undefined') {\n          for (var i=0; i<o.length; i++) {\n            // Array or FileList\n            if(callback(o[i])===false) return;\n          }\n        } else {\n          for (i in o) {\n            // Object\n            if(callback(i,o[i])===false) return;\n          }\n        }\n      },\n      generateUniqueIdentifier:function(file){\n        var custom = $.getOpt('generateUniqueIdentifier');\n        if(typeof custom === 'function') {\n          return custom(file);\n        }\n        var relativePath = file.webkitRelativePath||file.fileName||file.name; // Some confusion in different versions of Firefox\n        var size = file.size;\n        return(size + '-' + relativePath.replace(/[^0-9a-zA-Z_-]/img, ''));\n      },\n      contains:function(array,test) {\n        var result = false;\n\n        $h.each(array, function(value) {\n          if (value == test) {\n            result = true;\n            return false;\n          }\n          return true;\n        });\n\n        return result;\n      },\n      formatSize:function(size){\n        if(size<1024) {\n          return size + ' bytes';\n        } else if(size<1024*1024) {\n          return (size/1024.0).toFixed(0) + ' KB';\n        } else if(size<1024*1024*1024) {\n          return (size/1024.0/1024.0).toFixed(1) + ' MB';\n        } else {\n          return (size/1024.0/1024.0/1024.0).toFixed(1) + ' GB';\n        }\n      },\n      getTarget:function(params){\n        var target = $.getOpt('target');\n        if(target.indexOf('?') < 0) {\n          target += '?';\n        } else {\n          target += '&';\n        }\n        return target + params.join('&');\n      }\n    };\n\n    var onDrop = function(event){\n      $h.stopEvent(event);\n      appendFilesFromFileList(event.dataTransfer.files, event);\n    };\n    var onDragOver = function(e) {\n      e.preventDefault();\n    };\n\n    // INTERNAL METHODS (both handy and responsible for the heavy load)\n    var appendFilesFromFileList = function(fileList, event){\n      // check for uploading too many files\n      var errorCount = 0;\n      var o = $.getOpt(['maxFiles', 'minFileSize', 'maxFileSize', 'maxFilesErrorCallback', 'minFileSizeErrorCallback', 'maxFileSizeErrorCallback', 'fileType', 'fileTypeErrorCallback']);\n      if (typeof(o.maxFiles)!=='undefined' && o.maxFiles<(fileList.length+$.files.length)) {\n        // if single-file upload, file is already added, and trying to add 1 new file, simply replace the already-added file \n        if (o.maxFiles===1 && $.files.length===1 && fileList.length===1) {\n          $.removeFile($.files[0]);\n        } else {\n          o.maxFilesErrorCallback(fileList, errorCount++);\n          return false;\n        }\n      }\n      var files = [];\n      $h.each(fileList, function(file){\n        var fileName = file.name.split('.');\n        var fileType = fileName[fileName.length-1].toLowerCase();\n        \n        if (o.fileType.length > 0 && !$h.contains(o.fileType, fileType)) {\n          o.fileTypeErrorCallback(file, errorCount++);\n          return false;\n        }\n\n        if (typeof(o.minFileSize)!=='undefined' && file.size<o.minFileSize) {\n          o.minFileSizeErrorCallback(file, errorCount++);\n          return false;\n        }\n        if (typeof(o.maxFileSize)!=='undefined' && file.size>o.maxFileSize) {\n          o.maxFileSizeErrorCallback(file, errorCount++);\n          return false;\n        }\n\n        // directories have size == 0\n        if (!$.getFromUniqueIdentifier($h.generateUniqueIdentifier(file))) {(function(){\n          var f = new ResumableFile($, file);\n          window.setTimeout(function(){\n            $.files.push(f);\n            files.push(f);\n            f.container = (typeof event != 'undefined' ? event.srcElement : null);\n            $.fire('fileAdded', f, event)\n          },0);\n        })()};\n      });\n      window.setTimeout(function(){\n        $.fire('filesAdded', files)\n      },0);\n    };\n\n    // INTERNAL OBJECT TYPES\n    function ResumableFile(resumableObj, file){\n      var $ = this;\n      $.opts = {};\n      $.getOpt = resumableObj.getOpt;\n      $._prevProgress = 0;\n      $.resumableObj = resumableObj;\n      $.file = file;\n      $.fileName = file.fileName||file.name; // Some confusion in different versions of Firefox\n      $.size = file.size;\n      $.relativePath = file.webkitRelativePath || $.fileName;\n      $.uniqueIdentifier = $h.generateUniqueIdentifier(file);\n      $._pause = false;\n      $.container = '';\n      var _error = false;\n\n      // Callback when something happens within the chunk\n      var chunkEvent = function(event, message){\n        // event can be 'progress', 'success', 'error' or 'retry'\n        switch(event){\n        case 'progress':\n          $.resumableObj.fire('fileProgress', $);\n          break;\n        case 'error':\n          $.abort();\n          _error = true;\n          $.chunks = [];\n          $.resumableObj.fire('fileError', $, message);\n          break;\n        case 'success':\n          if(_error) return;\n          $.resumableObj.fire('fileProgress', $); // it's at least progress\n          if($.isComplete()) {\n            $.resumableObj.fire('fileSuccess', $, message);\n          }\n          break;\n        case 'retry':\n          $.resumableObj.fire('fileRetry', $);\n          break;\n        }\n      };\n\n      // Main code to set up a file object with chunks,\n      // packaged to be able to handle retries if needed.\n      $.chunks = [];\n      $.abort = function(){\n        // Stop current uploads\n        var abortCount = 0;\n        $h.each($.chunks, function(c){\n          if(c.status()=='uploading') {\n            c.abort();\n            abortCount++;\n          }\n        });\n        if(abortCount>0) $.resumableObj.fire('fileProgress', $);\n      };\n      $.cancel = function(){\n        // Reset this file to be void\n        var _chunks = $.chunks;\n        $.chunks = [];\n        // Stop current uploads\n        $h.each(_chunks, function(c){\n          if(c.status()=='uploading')  {\n            c.abort();\n            $.resumableObj.uploadNextChunk();\n          }\n        });\n        $.resumableObj.removeFile($);\n        $.resumableObj.fire('fileProgress', $);\n      };\n      $.retry = function(){\n        $.bootstrap();\n        var firedRetry = false;\n        $.resumableObj.on('chunkingComplete', function(){\n          if(!firedRetry) $.resumableObj.upload();\n          firedRetry = true;\n        });\n      };\n      $.bootstrap = function(){\n        $.abort();\n        _error = false;\n        // Rebuild stack of chunks from file\n        $.chunks = [];\n        $._prevProgress = 0;\n        var round = $.getOpt('forceChunkSize') ? Math.ceil : Math.floor;\n        var maxOffset = Math.max(round($.file.size/$.getOpt('chunkSize')),1);\n        for (var offset=0; offset<maxOffset; offset++) {(function(offset){\n            window.setTimeout(function(){\n                $.chunks.push(new ResumableChunk($.resumableObj, $, offset, chunkEvent));\n                $.resumableObj.fire('chunkingProgress',$,offset/maxOffset);\n            },0);\n        })(offset)}\n        window.setTimeout(function(){\n            $.resumableObj.fire('chunkingComplete',$);\n        },0);\n      };\n      $.progress = function(){\n        if(_error) return(1);\n        // Sum up progress across everything\n        var ret = 0;\n        var error = false;\n        $h.each($.chunks, function(c){\n          if(c.status()=='error') error = true;\n          ret += c.progress(true); // get chunk progress relative to entire file\n        });\n        ret = (error ? 1 : (ret>0.999 ? 1 : ret));\n        ret = Math.max($._prevProgress, ret); // We don't want to lose percentages when an upload is paused\n        $._prevProgress = ret;\n        return(ret);\n      };\n      $.isUploading = function(){\n        var uploading = false;\n        $h.each($.chunks, function(chunk){\n          if(chunk.status()=='uploading') {\n            uploading = true;\n            return(false);\n          }\n        });\n        return(uploading);\n      };    \n      $.isComplete = function(){\n        var outstanding = false;\n        $h.each($.chunks, function(chunk){\n          var status = chunk.status();\n          if(status=='pending' || status=='uploading' || chunk.preprocessState === 1) {\n            outstanding = true;\n            return(false);\n          }\n        });\n        return(!outstanding);\n      };\n      $.pause = function(pause){\n          if(typeof(pause)==='undefined'){\n              $._pause = ($._pause ? false : true);\n          }else{\n              $._pause = pause;\n          }\n      };\n      $.isPaused = function() {\n        return $._pause;\n      };\n\n\n      // Bootstrap and return\n      $.resumableObj.fire('chunkingStart', $);\n      $.bootstrap();\n      return(this);\n    }\n\n    function ResumableChunk(resumableObj, fileObj, offset, callback){\n      var $ = this;\n      $.opts = {};\n      $.getOpt = resumableObj.getOpt;\n      $.resumableObj = resumableObj;\n      $.fileObj = fileObj;\n      $.fileObjSize = fileObj.size;\n      $.fileObjType = fileObj.file.type;\n      $.offset = offset;\n      $.callback = callback;\n      $.lastProgressCallback = (new Date);\n      $.tested = false;\n      $.retries = 0;\n      $.pendingRetry = false;\n      $.preprocessState = 0; // 0 = unprocessed, 1 = processing, 2 = finished\n\n      // Computed properties\n      var chunkSize = $.getOpt('chunkSize');\n      $.loaded = 0;\n      $.startByte = $.offset*chunkSize;\n      $.endByte = Math.min($.fileObjSize, ($.offset+1)*chunkSize);\n      if ($.fileObjSize-$.endByte < chunkSize && !$.getOpt('forceChunkSize')) {\n        // The last chunk will be bigger than the chunk size, but less than 2*chunkSize\n        $.endByte = $.fileObjSize;\n      }\n      $.xhr = null;\n\n      // test() makes a GET request without any data to see if the chunk has already been uploaded in a previous session\n      $.test = function(){\n        // Set up request and listen for event\n        $.xhr = new XMLHttpRequest();\n\n        var testHandler = function(e){\n          $.tested = true;\n          var status = $.status();\n          if(status=='success') {\n            $.callback(status, $.message());\n            $.resumableObj.uploadNextChunk();\n          } else {\n            $.send();\n          }\n        };\n        $.xhr.addEventListener('load', testHandler, false);\n        $.xhr.addEventListener('error', testHandler, false);\n\n        // Add data from the query options\n        var params = [];\n        var customQuery = $.getOpt('query'); \n        if(typeof customQuery == 'function') customQuery = customQuery($.fileObj, $);\n        $h.each(customQuery, function(k,v){\n          params.push([encodeURIComponent(k), encodeURIComponent(v)].join('='));\n        });\n        // Add extra data to identify chunk\n        params.push(['resumableChunkNumber', encodeURIComponent($.offset+1)].join('='));\n        params.push(['resumableChunkSize', encodeURIComponent($.getOpt('chunkSize'))].join('='));\n        params.push(['resumableCurrentChunkSize', encodeURIComponent($.endByte - $.startByte)].join('='));\n        params.push(['resumableTotalSize', encodeURIComponent($.fileObjSize)].join('='));\n        params.push(['resumableType', encodeURIComponent($.fileObjType)].join('='));\n        params.push(['resumableIdentifier', encodeURIComponent($.fileObj.uniqueIdentifier)].join('='));\n        params.push(['resumableFilename', encodeURIComponent($.fileObj.fileName)].join('='));\n        params.push(['resumableRelativePath', encodeURIComponent($.fileObj.relativePath)].join('='));\n        params.push(['resumableTotalChunks', encodeURIComponent($.fileObj.chunks.length)].join('='));\n        // Append the relevant chunk and send it\n        $.xhr.open('GET', $h.getTarget(params));\n        $.xhr.timeout = $.getOpt('xhrTimeout');\n        $.xhr.withCredentials = $.getOpt('withCredentials');\n        // Add data from header options\n        $h.each($.getOpt('headers'), function(k,v) {\n          $.xhr.setRequestHeader(k, v);\n        });\n        $.xhr.send(null);\n      };\n\n      $.preprocessFinished = function(){\n        $.preprocessState = 2;\n        $.send();\n      };\n\n      // send() uploads the actual data in a POST call\n      $.send = function(){\n        var preprocess = $.getOpt('preprocess');\n        if(typeof preprocess === 'function') {\n          switch($.preprocessState) {\n          case 0: preprocess($); $.preprocessState = 1; return;\n          case 1: return;\n          case 2: break;\n          }\n        }\n        if($.getOpt('testChunks') && !$.tested) {\n          $.test();\n          return;\n        }\n\n        // Set up request and listen for event\n        $.xhr = new XMLHttpRequest();\n\n        // Progress\n        $.xhr.upload.addEventListener('progress', function(e){\n          if( (new Date) - $.lastProgressCallback > $.getOpt('throttleProgressCallbacks') * 1000 ) {\n            $.callback('progress');\n            $.lastProgressCallback = (new Date);\n          }\n          $.loaded=e.loaded||0;\n        }, false);\n        $.loaded = 0;\n        $.pendingRetry = false;\n        $.callback('progress');\n\n        // Done (either done, failed or retry)\n        var doneHandler = function(e){\n          var status = $.status();\n          if(status=='success'||status=='error') {\n            $.callback(status, $.message());\n            $.resumableObj.uploadNextChunk();\n          } else {\n            $.callback('retry', $.message());\n            $.abort();\n            $.retries++;\n            var retryInterval = $.getOpt('chunkRetryInterval');          \n            if(retryInterval !== undefined) {\n              $.pendingRetry = true;\n              setTimeout($.send, retryInterval);\n            } else {\n              $.send();\n            }\n          }\n        };\n        $.xhr.addEventListener('load', doneHandler, false);\n        $.xhr.addEventListener('error', doneHandler, false);\n\n        // Set up the basic query data from Resumable\n        var query = {\n          resumableChunkNumber: $.offset+1,\n          resumableChunkSize: $.getOpt('chunkSize'),\n          resumableCurrentChunkSize: $.endByte - $.startByte,\n          resumableTotalSize: $.fileObjSize,\n          resumableType: $.fileObjType,\n          resumableIdentifier: $.fileObj.uniqueIdentifier,\n          resumableFilename: $.fileObj.fileName,\n          resumableRelativePath: $.fileObj.relativePath,\n          resumableTotalChunks: $.fileObj.chunks.length\n        };\n        // Mix in custom data\n        var customQuery = $.getOpt('query');\n        if(typeof customQuery == 'function') customQuery = customQuery($.fileObj, $);\n        $h.each(customQuery, function(k,v){\n          query[k] = v;\n        });\n\n        var func   = ($.fileObj.file.slice ? 'slice' : ($.fileObj.file.mozSlice ? 'mozSlice' : ($.fileObj.file.webkitSlice ? 'webkitSlice' : 'slice'))),\n        bytes  = $.fileObj.file[func]($.startByte,$.endByte), \n        data   = null,\n        target = $.getOpt('target');\n        \n        if ($.getOpt('method') === 'octet') {\n          // Add data from the query options\n          data = bytes;\n          var params = [];\n          $h.each(query, function(k,v){\n            params.push([encodeURIComponent(k), encodeURIComponent(v)].join('='));\n          });\n          target = $h.getTarget(params);\n        } else {\n          // Add data from the query options\n          data = new FormData();\n          $h.each(query, function(k,v){\n            data.append(k,v);\n          });\n          data.append($.getOpt('fileParameterName'), bytes);\n        }\n        \n        $.xhr.open('POST', target);\n        $.xhr.timeout = $.getOpt('xhrTimeout');\n        $.xhr.withCredentials = $.getOpt('withCredentials');\n        // Add data from header options\n        $h.each($.getOpt('headers'), function(k,v) {\n          $.xhr.setRequestHeader(k, v);\n        });\n        $.xhr.send(data);\n      };\n      $.abort = function(){\n        // Abort and reset\n        if($.xhr) $.xhr.abort();\n        $.xhr = null;\n      };\n      $.status = function(){\n        // Returns: 'pending', 'uploading', 'success', 'error'\n        if($.pendingRetry) {\n          // if pending retry then that's effectively the same as actively uploading,\n          // there might just be a slight delay before the retry starts\n          return('uploading');\n        } else if(!$.xhr) {\n          return('pending');\n        } else if($.xhr.readyState<4) {\n          // Status is really 'OPENED', 'HEADERS_RECEIVED' or 'LOADING' - meaning that stuff is happening\n          return('uploading');\n        } else {\n          if($.xhr.status==200) {\n            // HTTP 200, perfect\n            return('success');\n          } else if($h.contains($.getOpt('permanentErrors'), $.xhr.status) || $.retries >= $.getOpt('maxChunkRetries')) {\n            // HTTP 415/500/501, permanent error\n            return('error');\n          } else {\n            // this should never happen, but we'll reset and queue a retry\n            // a likely case for this would be 503 service unavailable\n            $.abort();\n            return('pending');\n          }\n        }\n      };\n      $.message = function(){\n        return($.xhr ? $.xhr.responseText : '');\n      };\n      $.progress = function(relative){\n        if(typeof(relative)==='undefined') relative = false;\n        var factor = (relative ? ($.endByte-$.startByte)/$.fileObjSize : 1);\n        if($.pendingRetry) return(0);\n        var s = $.status();\n        switch(s){\n        case 'success':\n        case 'error':\n          return(1*factor);\n        case 'pending':\n          return(0*factor);\n        default:\n          return($.loaded/($.endByte-$.startByte)*factor);\n        }\n      };\n      return(this);\n    }\n\n    // QUEUE\n    $.uploadNextChunk = function(){\n      var found = false;\n\n      // In some cases (such as videos) it's really handy to upload the first\n      // and last chunk of a file quickly; this let's the server check the file's\n      // metadata and determine if there's even a point in continuing.\n      if ($.getOpt('prioritizeFirstAndLastChunk')) {\n        $h.each($.files, function(file){\n          if(file.chunks.length && file.chunks[0].status()=='pending' && file.chunks[0].preprocessState === 0) {\n            file.chunks[0].send();\n            found = true;\n            return(false);\n          }\n          if(file.chunks.length>1 && file.chunks[file.chunks.length-1].status()=='pending' && file.chunks[file.chunks.length-1].preprocessState === 0) {\n            file.chunks[file.chunks.length-1].send();\n            found = true;\n            return(false);\n          }\n        });\n        if(found) return(true);\n      }\n\n      // Now, simply look for the next, best thing to upload\n      $h.each($.files, function(file){\n        if(file.isPaused()===false){\n         $h.each(file.chunks, function(chunk){\n           if(chunk.status()=='pending' && chunk.preprocessState === 0) {\n             chunk.send();\n             found = true;\n             return(false);\n           }\n          });\n        }\n        if(found) return(false);\n      });\n      if(found) return(true);\n\n      // The are no more outstanding chunks to upload, check is everything is done\n      var outstanding = false;\n      $h.each($.files, function(file){\n        if(!file.isComplete()) {\n          outstanding = true;\n          return(false);\n        }\n      });\n      if(!outstanding) {\n        // All chunks have been uploaded, complete\n        $.fire('complete');\n      }\n      return(false);\n    };\n\n\n    // PUBLIC METHODS FOR RESUMABLE.JS\n    $.assignBrowse = function(domNodes, isDirectory){\n      if(typeof(domNodes.length)=='undefined') domNodes = [domNodes];\n\n      $h.each(domNodes, function(domNode) {\n        var input;\n        if(domNode.tagName==='INPUT' && domNode.type==='file'){\n          input = domNode;\n        } else {\n          input = document.createElement('input');\n          input.setAttribute('type', 'file');\n          input.style.display = 'none';\n          domNode.addEventListener('click', function(){\n            input.style.opacity = 0;\n            input.style.display='block';\n            input.focus();\n            input.click();\n            input.style.display='none';\n          }, false);\n          domNode.appendChild(input);\n        }\n        var maxFiles = $.getOpt('maxFiles');\n        if (typeof(maxFiles)==='undefined'||maxFiles!=1){\n          input.setAttribute('multiple', 'multiple');\n        } else {\n          input.removeAttribute('multiple');\n        }\n        if(isDirectory){\n          input.setAttribute('webkitdirectory', 'webkitdirectory');\n        } else {\n          input.removeAttribute('webkitdirectory');\n        }\n        // When new files are added, simply append them to the overall list\n        input.addEventListener('change', function(e){\n          appendFilesFromFileList(e.target.files,e);\n          e.target.value = '';\n        }, false);\n      });\n    };\n    $.assignDrop = function(domNodes){\n      if(typeof(domNodes.length)=='undefined') domNodes = [domNodes];\n\n      $h.each(domNodes, function(domNode) {\n        domNode.addEventListener('dragover', onDragOver, false);\n        domNode.addEventListener('drop', onDrop, false);\n      });\n    };\n    $.unAssignDrop = function(domNodes) {\n      if (typeof(domNodes.length) == 'undefined') domNodes = [domNodes];\n\n      $h.each(domNodes, function(domNode) {\n        domNode.removeEventListener('dragover', onDragOver);\n        domNode.removeEventListener('drop', onDrop);\n      });\n    };\n    $.isUploading = function(){\n      var uploading = false;\n      $h.each($.files, function(file){\n        if (file.isUploading()) {\n          uploading = true;\n          return(false);\n        }\n      });\n      return(uploading);\n    };\n    $.upload = function(){\n      // Make sure we don't start too many uploads at once\n      if($.isUploading()) return;\n      // Kick off the queue\n      $.fire('uploadStart');\n      for (var num=1; num<=$.getOpt('simultaneousUploads'); num++) {\n        $.uploadNextChunk();\n      }\n    };\n    $.pause = function(){\n      // Resume all chunks currently being uploaded\n      $h.each($.files, function(file){\n        file.abort();\n      });\n      $.fire('pause');\n    };\n    $.cancel = function(){\n      for(var i = $.files.length - 1; i >= 0; i--) {\n        $.files[i].cancel();\n      }\n      $.fire('cancel');\n    };\n    $.progress = function(){\n      var totalDone = 0;\n      var totalSize = 0;\n      // Resume all chunks currently being uploaded\n      $h.each($.files, function(file){\n        totalDone += file.progress()*file.size;\n        totalSize += file.size;\n      });\n      return(totalSize>0 ? totalDone/totalSize : 0);\n    };\n    $.addFile = function(file, event){\n      appendFilesFromFileList([file], event);\n    };\n    $.removeFile = function(file){\n      for(var i = $.files.length - 1; i >= 0; i--) {\n        if($.files[i] === file) {\n          $.files.splice(i, 1);\n        }\n      }\n    };\n    $.getFromUniqueIdentifier = function(uniqueIdentifier){\n      var ret = false;\n      $h.each($.files, function(f){\n        if(f.uniqueIdentifier==uniqueIdentifier) ret = f;\n      });\n      return(ret);\n    };\n    $.getSize = function(){\n      var totalSize = 0;\n      $h.each($.files, function(file){\n        totalSize += file.size;\n      });\n      return(totalSize);\n    };\n\n    return(this);\n  };\n\n\n  // Node.js-style export for Node and Component\n  if (typeof module != 'undefined') {\n    module.exports = Resumable;\n  } else if (typeof define === \"function\" && define.amd) {\n    // AMD/requirejs: Define the module\n    define(function(){\n      return Resumable;\n    });\n  } else {\n    // Browser: Expose to window\n    window.Resumable = Resumable;\n  }\n\n})();\n","############################################################################\n#     Copyright (C) 2014 by Vaughn Iverson\n#     fileCollection is free software released under the MIT/X11 license.\n#     See included LICENSE file for details.\n############################################################################\n\nif Meteor.isClient\n\n   share.setup_resumable = () ->\n      r = new Resumable\n         target: \"#{@baseURL}/_resumable\"\n         generateUniqueIdentifier: (file) -> \"#{new Meteor.Collection.ObjectID()}\"\n         fileParameterName: 'file'\n         chunkSize: @chunkSize\n         testChunks: true\n         simultaneousUploads: 3\n         maxFiles: undefined\n         maxFilesErrorCallback: undefined\n         prioritizeFirstAndLastChunk: false\n         query: undefined\n         headers: {}\n\n      unless r.support\n         console.error \"resumable.js not supported by this Browser, uploads will be disabled\"\n         @resumable = null\n      else\n         # Autoupdate the token depending on who is logged in\n         # if Accounts?\n         #    Deps.autorun () =>\n         #       Meteor.userId()   # Accounts._storedLoginToken() isn't reactive\n         #       r.opts.headers['X-Auth-Token'] = Accounts._storedLoginToken() ? ''\n         @resumable = r","############################################################################\n#     Copyright (C) 2014 by Vaughn Iverson\n#     fileCollection is free software released under the MIT/X11 license.\n#     See included LICENSE file for details.\n############################################################################\n\nif Meteor.isClient\n\n   class FileCollection extends Meteor.Collection\n\n      constructor: (@root = share.defaultRoot, options = {}) ->\n         unless @ instanceof FileCollection\n            return new FileCollection(root, options)\n\n         if typeof @root is 'object'\n            options = @root\n            @root = share.defaultRoot\n\n         @base = @root\n         @baseURL = options.baseURL ? \"/gridfs/#{@root}\"\n         @chunkSize = options.chunkSize ? share.defaultChunkSize\n         super @root + '.files', { idGeneration: 'MONGO' }\n\n         # This call sets up the optional support for resumable.js\n         # See the resumable.coffee file for more information\n         if options.resumable\n            share.setup_resumable.bind(@)()\n\n      # remove works as-is. No modifications necessary so it currently goes straight to super\n\n      upsert: () ->\n         throw new Error \"File Collections do not support 'upsert'\"\n\n      update: () ->\n         throw new Error \"File Collections do not support 'update' on client, use method calls instead\"\n\n      # Insert only creates an empty (but valid) gridFS file. To put data into it from a client,\n      # you need to use an HTTP POST or PUT after the record is inserted. For security reasons,\n      # you shouldn't be able to POST or PUT to a file that hasn't been inserted.\n\n      insert: (file, callback = undefined) ->\n         # This call ensures that a full gridFS file document\n         # gets built from whatever is provided\n         file = share.insert_func file, @chunkSize\n         super file, callback\n\n   # Encapsulating class for deprecation warning\n   class fileCollection extends FileCollection\n      constructor: (r = share.defaultRoot, o = {}) ->\n         unless @ instanceof fileCollection\n            return new fileCollection(r, o)\n         console.warn '******************************************************'\n         console.warn '** The \"fileCollection\" global object is deprecated'\n         console.warn '** It will be removed in v0.2.0'\n         console.warn '**'\n         console.warn '** Use \"FileCollection\" instead (with capital \"F\")'\n         console.warn '******************************************************'\n         super r, o"]}