)]}'
{"version":3,"file":"/packages/autoupdate.js","sources":["autoupdate/autoupdate_cordova.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,+F;;AAEA,gD;AACA,2E;;AAEA,gB;;AAEA,6C;AACA,oC;AACA,2B;AACA,4C;AACA,K;AACA,E;;AAEA,iE;AACA,6B;AACA,uD;AACA,I;AACA,iD;AACA,yB;AACA,0C;AACA,kD;AACA,2C;AACA,2C;AACA,6B;AACA,Y;AACA,gC;AACA,gC;AACA,iB;AACA,Q;;AAEA,oE;AACA,uB;AACA,a;AACA,E;;AAEA,yC;AACA,yD;AACA,gF;AACA,qE;;AAEA,gB;AACA,gC;AACA,W;AACA,G;;AAEA,uD;AACA,a;AACA,kB;AACA,qC;AACA,uB;AACA,qD;AACA,K;AACA,uB;AACA,4B;AACA,oB;AACA,qC;AACA,uB;AACA,sC;AACA,a;AACA,I;;AAEA,mD;AACA,iC;AACA,2B;AACA,iD;AACA,sC;AACA,0C;AACA,iB;AACA,c;AACA,8B;AACA,mC;AACA,O;AACA,a;AACA,W;AACA,E;;AAEA,4B;AACA,gC;AACA,8B;AACA,qD;;AAEA,kE;AACA,4C;;;AAGA,8D;AACA,4B;AACA,0G;AACA,a;AACA,K;;AAEA,2B;AACA,6C;AACA,kC;AACA,gC;;AAEA,yD;;AAEA,sB;AACA,sC;AACA,gC;AACA,O;;AAEA,kD;;AAEA,kE;AACA,+C;AACA,gD;AACA,0B;;AAEA,kB;AACA,uD;AACA,sC;AACA,iB;AACA,S;;AAEA,iE;AACA,gD;AACA,sD;AACA,4B;AACA,oB;AACA,mD;AACA,mB;AACA,W;;AAEA,qC;AACA,kC;AACA,2C;AACA,+D;AACA,oC;AACA,W;AACA,W;AACA,S;AACA,O;;AAEA,sC;AACA,6B;;AAEA,yB;AACA,qC;;AAEA,uE;AACA,+D;;AAEA,6C;AACA,oB;AACA,qC;AACA,gE;AACA,sB;AACA,sC;AACA,W;AACA,2B;AACA,qE;AACA,4B;AACA,0B;AACA,kB;AACA,uD;AACA,uD;AACA,W;AACA,W;AACA,Q;;AAEA,oB;AACA,O;AACA,K;AACA,E;;AAEA,uB;AACA,gD;AACA,wC;AACA,G;AACA,iB;;AAEA,6C;AACA,uD;AACA,+B;AACA,8D;AACA,iB;AACA,8C;AACA,qE;AACA,qE;AACA,wE;AACA,mE;AACA,+D;AACA,wE;AACA,+B;AACA,wC;AACA,S;AACA,K;AACA,K;AACA,uB;AACA,kD;AACA,sB;AACA,qD;AACA,uB;AACA,O;AACA,M;;AAEA,sC;AACA,4B;AACA,gB;AACA,qC;AACA,sC;AACA,O;AACA,G;AACA,E;;AAEA,8C","sourcesContent":["var autoupdateVersionCordova = __meteor_runtime_config__.autoupdateVersionCordova || \"unknown\";\n\n// The collection of acceptable client versions.\nClientVersions = new Meteor.Collection(\"meteor_autoupdate_clientVersions\");\n\nAutoupdate = {};\n\nAutoupdate.newClientAvailable = function () {\n  return !! ClientVersions.findOne({\n    _id: 'version-cordova',\n    version: {$ne: autoupdateVersionCordova}\n  });\n};\n\nvar writeFile = function (directoryPath, fileName, content, cb) {\n  var fail = function (err) {\n    cb(new Error(\"Failed to write file: \", err), null);\n  };\n  window.resolveLocalFileSystemURL(directoryPath,\n    function (dirEntry) {\n      var success = function (fileEntry) {\n        fileEntry.createWriter(function (writer) {\n          writer.onwrite = function (evt) {\n            var result = evt.target.result;\n            cb(null, result);\n          };\n          writer.onerror = fail;\n          writer.write(content);\n        }, fail);\n      };\n\n      dirEntry.getFile(fileName, { create: true, exclusive: false },\n        success, fail);\n    }, fail);\n};\n\nvar restartServer = function (location) {\n  console.log('restartserver with location ' + location);\n  var fail = function (err) { console.log('something failed: ' + err.message) };\n  var httpd = cordova && cordova.plugins && cordova.plugins.CorHttpd;\n\n  if (! httpd) {\n    fail(new Error('no httpd'));\n    return;\n  }\n\n  var startServer = function (cordovajsRoot, prevUrl) {\n    var port;\n    if (prevUrl) {\n      var parts = prevUrl.split(':');\n      if (parts.length)\n        port = parseInt(parts[parts.length - 1], 10);\n    }\n    httpd.startServer({\n      'www_root' : location,\n      'port' : port,\n      'cordovajs_root': cordovajsRoot\n    }, function (url) {\n      Package.reload.Reload._reload();\n    }, fail);\n  };\n\n  httpd.getCordovajsRoot(function (cordovajsRoot) {\n    httpd.getURL(function (url) {\n      if (url.length > 0) {\n        // already have a server running, stop it\n        httpd.stopServer(function () {\n          startServer(cordovajsRoot, url);\n        }, fail);\n      } else {\n        // just start a server\n        startServer(cordovajsRoot);\n      }\n    }, fail);\n  }, fail);\n};\n\nvar hasCalledReload = false;\nvar onNewVersion = function () {\n  var ft = new FileTransfer();\n  var urlPrefix = Meteor.absoluteUrl() + '__cordova';\n\n  var localPathPrefix = cordova.file.applicationStorageDirectory +\n                        'Documents/meteor/';\n\n\n  HTTP.get(urlPrefix + '/manifest.json', function (err, res) {\n    if (err || ! res.data) {\n      console.log('failed to download the manifest ' + (err && err.message) + ' ' + (res && res.content));\n      return;\n    }\n\n    var program = res.data;\n    var manifest = _.clone(program.manifest);\n    var version = program.version;\n    var ft = new FileTransfer();\n\n    manifest.push({ url: '/index.html?' + Random.id() });\n\n    var downloads = 0;\n    _.each(manifest, function (item) {\n      if (item.url) downloads++;\n    });\n\n    var versionPrefix = localPathPrefix + version;\n\n    var afterAllFilesDownloaded = _.after(downloads, function () {\n      writeFile(versionPrefix, 'manifest.json',\n          JSON.stringify(program, undefined, 2),\n          function (err) {\n\n        if (err) {\n          console.log(\"Failed to write manifest.json\");\n          // XXX do something smarter?\n          return;\n        }\n\n        // success! downloaded all sources and saved the manifest\n        // save the version string for atomicity\n        writeFile(localPathPrefix, 'version', version,\n            function (err) {\n          if (err) {\n            console.log(\"Failed to write version\");\n            return;\n          }\n\n          // don't call reload twice!\n          if (! hasCalledReload) {\n            // relative to 'bundle.app/www'\n            var location = '../../Documents/meteor/' + version;\n            restartServer(location);\n          }\n        });\n      });\n    });\n\n    _.each(manifest, function (item) {\n      if (! item.url) return;\n\n      var url = item.url;\n      url = url.replace(/\\?.+$/, '');\n\n      // Add a cache buster to ensure that we don't cache an old asset.\n      var uri = encodeURI(urlPrefix + url + '?' + Random.id());\n\n      // Try to dowload the file a few times.\n      var tries = 0;\n      var tryDownload = function () {\n        ft.download(uri, versionPrefix + url, function (entry) {\n          if (entry) {\n            afterAllFilesDownloaded();\n          }\n        }, function (err) {\n          // It failed, try again if we have tried less than 5 times.\n          if (tries++ < 5) {\n            tryDownload();\n          } else {\n            console.log('fail source: ', error.source);\n            console.log('fail target: ', error.target);\n          }\n        });\n      };\n\n      tryDownload();\n    });\n  });\n};\n\nvar retry = new Retry({\n  minCount: 0, // don't do any immediate retries\n  baseTimeout: 30*1000 // start with 30s\n});\nvar failures = 0;\n\nAutoupdate._retrySubscription = function () {\n Meteor.subscribe(\"meteor_autoupdate_clientVersions\", {\n    onError: function (error) {\n      Meteor._debug(\"autoupdate subscription failed:\", error);\n      failures++;\n      retry.retryLater(failures, function () {\n        // Just retry making the subscription, don't reload the whole\n        // page. While reloading would catch more cases (for example,\n        // the server went back a version and is now doing old-style hot\n        // code push), it would also be more prone to reload loops,\n        // which look really bad to the user. Just retrying the\n        // subscription over DDP means it is at least possible to fix by\n        // updating the server.\n        Autoupdate._retrySubscription();\n      });\n    }\n  });\n  if (Package.reload) {\n    var checkNewVersionDocument = function (doc) {\n      var self = this;\n      if (doc.version !== autoupdateVersionCordova) {\n        onNewVersion();\n      }\n    };\n\n    var handle = ClientVersions.find({\n      _id: 'version-cordova'\n    }).observe({\n      added: checkNewVersionDocument,\n      changed: checkNewVersionDocument\n    });\n  }\n};\n\nMeteor.startup(Autoupdate._retrySubscription);\n"]}